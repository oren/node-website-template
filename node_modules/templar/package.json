{
  "author": {
    "name": "Isaac Z. Schlueter",
    "email": "i@izs.me",
    "url": "http://blog.izs.me/"
  },
  "name": "templar",
  "description": "A lightweight template thing",
  "version": "0.0.11",
  "repository": {
    "url": "git://github.com/isaacs/templar.git"
  },
  "main": "templar.js",
  "dependencies": {
    "lru-cache": "~1.1.0"
  },
  "devDependencies": {
    "ejs": "~0.7.1",
    "tap": "~0.2.4",
    "request": "~2.9.202"
  },
  "scripts": {
    "test": "tap test/*.js"
  },
  "readme": "# templar\n\nA minimal template thing for node.js web sites to use.\n\nWorks with any template engine that works with Express.\n\nAutomatically sends ETags based on the data and the template being used,\nand 304 responses based on the `If-None-Match` request header, if the\nuser would be getting the same exact response as last time.\n\n## Example\n\n```javascript\nvar ejs = require('ejs')\n, Templar = require('templar')\n, templarOptions = { engine: ejs, folder: './templates' }\n\n// preload it.  Otherwise, the first request is slow, because\n// it has to load up all the templates within it.\nTemplar.loadFolder('./templates')\n\nhttp.createServer(function (req, res) {\n  // note that this causes a sync fs hit the first time if\n  // the folder has not been loaded yet.\n  res.template = Templar(req, res, templarOptions)\n\n  // .. later, after figuring out which template to use ..\n  res.template('foo.ejs', { some: 'data', for: [ 'the', 'template'] })\n}).listen(PORT)\n```\n\n## Options\n\n* `engine`: The engine to use.  EJS and Jade both work.\n* `folder`: The folder where template files are found.\n* `cache`: Boolean. Set to `false` to suppress 304 responses.\n\n## Partials\n\nEvery template will be provided with a local function\n`include(file, data)`.  This function will include another template via\na relative path, run it using the data provided, and return the string.\n\nNote that this does not automatically dump the data into the calling\ntemplate!  It's still the caller's responsibility to actually print out\nthe result.\n\n### Example\n\nIf the template `full.ejs` contains this:\n\n```ejs\n<!doctype html ALL UP IN YOUR FACE>\n<html>\n<head><title>yoyoyoyo</title>\n<body>\n<%- include(\"partial.ejs\", { partial: 1 }) %>\n<%- include(\"partial.ejs\", { partial: 2 }) %>\n<%- include(\"partial.ejs\", { partial: 3 }) %>\n<%- include(\"partial.ejs\", { partial: 4 }) %>\n<%- include(\"partial.ejs\", { partial: 5 }) %>\n</body></html>\n```\n\nThen, in the same folder, you had a `partial.ejs` that contained:\n\n```ejs\n<p>is for <%= partial %>\n```\n\nthen the resulting output would be:\n\n```html\n<!doctype html ALL UP IN YOUR FACE>\n<html>\n<head><title>yoyoyoyo</title>\n<body>\n<p>is for 1\n\n<p>is for 2\n\n<p>is for 3\n\n<p>is for 4\n\n<p>is for 5\n\n</body></html>\n```\n\nNote that `full.ejs` actually prints out the result of the include call.\n",
  "readmeFilename": "README.md",
  "_id": "templar@0.0.11",
  "_from": "templar@~0.0.6"
}
